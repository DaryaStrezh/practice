# Одномерный массив
Массив представляет набор однотипных данных. 
```cpp
тип_переменной название_массива [длина_массива]
```
Число элементов массив можно определять через число или константу:
```cpp
int numbers[4];
// or
const int n = 4;
int numbers[n];
```
Чтобы установить значения элементов массива, указываются фигурные скобки (инициализатор), внутри которых перечисляются значения для элементов массива:
```cpp
int numbers[4] {};   //  {0, 0, 0, 0}
int numbers[4] {1, 2, 3, 4};
int numbers[4] {1, 2};   //  {1, 2, 0, 0}
int numbers[4] {1, 2, 3, 4, 5, 6};   // ! Ошибка
```
Если размер массива не указан явно, то он выводится из количества переданных значений:
```cpp
int numbers[] {1, 2, 3, 4, 5, 6};
```
### Индексы 
Индексы начинаются с нуля, поэтому для обращения к первому элементу необходимо использовать индекс 0. Обратившись к элементу по индексу, мы можем получить его значение, либо изменить его. 
### Константные массивы
Если необходимо, чтобы нельзя было изменять значения элементов массива, то такой массив можно определить как константный с помощью ключевого слова const
```cpp
const int numbers[4]{1,2,3,4};
```
### Длина массива
1. <b>sizeof</b>
Длина массива равна совокупной длине его элементов. Все элементы представляют один и тот же тип и занимают один и тот же размер в памяти. Поэтому с помощью выражения sizeof(numbers) находим длину всего массива в байтах, а с помощью выражения sizeof(numbers[0]) - длину одного элемента в байтах. Разделив два значения, можно получить количество элементов в массиве.
```cpp
    int numbers[]{11, 12, 13, 14};
    std::cout << "Length: " << sizeof(numbers) / sizeof(numbers[0]) << std::endl;   // Length: 4
```
2. <b>std::size()</b>
```cpp  
int numbers[]{11, 12, 13, 14};
int count = std::size(numbers);
std::cout << "Length: " << count << std::endl;   // Length: 4
```
### Перебор массивов
1. Если знаем длину массива
```cpp  
const int n = 4;
int numbers[n] {11, 12, 13, 14};
for(int i=0; i < n; i++)  std::cout << numbers[i] << std::endl;
```
2. Если не знаем длину массива
```cpp
int numbers[]{1, 2, 3, 4};
int sum {};
for (int i {}; i < std::size(numbers); sum += numbers[i++]);
std::cout << "Sum: " << sum << std::endl;   // Sum: 10
```
### Перебор элементов в стиле for-each
```cpp
int numbers[4] {1,2,3,4};
for(int n : numbers) std::cout << n << std::endl;
```
### Ввод значений массива с консоли
```cpp
#include <iostream>
  
int main(){
    const int max {6};     // максимальная длина массива - не больше 6 чисел
    int numbers[max];       // массив для ввода чисел
  
    int i{};        // счетчик введенных чисел
    std::cout << "Enter numbers" << std::endl;
    while(i < max)    {
        std::cin >> numbers[i];    // вводим число
        i++;
    }
    // выводим массив
    for (i =0; i < max; ++i)    {
        std::cout << numbers[i] << "\t";
    }
    std::cout << std::endl;
}
```
# Многомерные массивы
```cpp
int numbers[3][2]; // двухмерный массив чисел
int numbers[3][2][2]; // трехмерный массив
int numbers[3][2] 
{ 
    {1, 2},     // первая строка
    {4, 5},     // вторая строка
    {7, 8}      // третья строка
};
// инициализация не всех элементов, а только некоторых
int numbers[3][2] { {1, 2}, {}, {7} };
// При инициализации многомерных массивов тоже тоже можно опустить длину массива, но только первую размерность (первые квадратные скобки):
int numbers[][2] { {1, 2}, {3, 4}, {5, 6} };
```
### Обращение к элементам
```cpp
#include <iostream>
  
int main() {   
    int nums[3][2]     { 
        {1, 2}, 
        {3, 4}, 
        {5, 6} 
    };
    // получаем значение элемента
    int n = nums[1][0];     // вторая строка, первый столбец
    std::cout << "n =" << n << std::endl;       // n = 3
 
    std::cout << "nums[2][1] = " << nums[2][1] << std::endl;   // nums[2][1] = 6 
    // изменяем значение элемента
    nums[2][1] = 123;       // третья строка, второй столбец
    std::cout << "nums[2][1] = " << nums[2][1] << std::endl;   // nums[2][1] = 123 
}
```
### Перебор многомерного массива
```cpp
#include <iostream>
 
int main(){
    const int rows = 3, columns = 2;
    int numbers[rows][columns]  { {1, 2}, {3, 4}, {5, 6} };
    for(int i=0; i < rows; i++)    {
        for(int j=0; j < columns; j++)       {
            std::cout << numbers[i] [j] << "\t";
        }
        std::cout << std::endl;
    }
}
// or
#include <iostream>
 
int main(){
    const int rows = 3, columns = 2;
    int numbers[rows][columns]  { {1, 2}, {3, 4}, {5, 6} };
     
    for(auto &subnumbers : numbers)    {
        for(int number : subnumbers)        {
            std::cout << number << "\t";
        }
        std::cout << std::endl;
    }
}
```
Для перебора массивов, которые входят в массив, применяются ссылки. То есть во внешнем цикле for(auto &subnumbers : numbers) &subnumbers представляет ссылку на подмассив в массиве. Во внутреннем цикле for(int number : subnumbers) из каждого подмассива в subnumbers получаем отдельные его элементы в переменную number и выводим ее значение на консоль.
# Массивы символов
 При инициализации мы можем передать символьному массиву как набор символов, так и строку:
```cpp
char hello1[] {'h', 'e', 'l', 'l', 'o'};
char hello2[] {"hello"};    // {'h', 'e', 'l', 'l', 'o', '0'}
```
### Двухмерные массивы символов
```cpp
#include <iostream>
  
int main(){   
    const int max_length{50}; // максимальная длина строки (включая нулевой байт \0)
    char langs[][max_length] 
    {
        "C++", "C#",  "Python", "Java",
        "Kotlin", "Go", "Dart", "PHP"
    };
    std::cout << langs[0] << std::endl;     // C++
    std::cout << langs[1] << std::endl;     // C#
    std::cout << langs[2] << std::endl;     // Python
}
```
### Перебор двухмерных символьных массивов
```cpp
#include <iostream>
   
int main(){
    char langs[][20] { "C++", "Python", "JavaScript"};
    for(auto lang : langs)    {
        std::cout << lang << std::endl;
    }
}
```
### Ввод символьных массивов/строк с консоли
Функция getline() потока cin считывает последовательность символов, включая пробелы. По умолчанию, ввод заканчивается, когда считывается символ перевода строки '\n' (например, при нажатии клавиши Enter). Функция getline() имеет две версии. Первая версия принимает два параметра: первый параметра указывает на массив символов для хранения введенных данных, а второй параметр указывает на максимальное количество символов, которое надо сохранить в массив. Это количество включает символ завершения строки - нулевой байт '\0', который автоматически добавляться в конец ввода:
```cpp
#include <iostream>
  
int main(){   
    const int max_length {100};    // максимальное количиство считываемых символов
    char text[max_length] {};       // массив для считывания строки
    std::cout << "Enter some text:" << std::endl;
    // считываем символы, включая пробелы
    std::cin.getline(text, max_length);
    std::cout << "You entered:\n" << text << std::endl;
}
```
Другая форма функции getline() также принимает третий параметр - символ, который будет выступать сиигналом завершения ввода. Например
```cpp
#include <iostream>
  
int main(){   
    const int max_length {100};    // максимальное количиство считываемых символов
    char text[max_length] {};       // массив для считывания строки
    std::cout << "Enter some text:" << std::endl;
    // считываем символы, включая пробелы
    std::cin.getline(text, max_length, '!');
    std::cout << "You entered:\n" << text << std::endl;
}
```
