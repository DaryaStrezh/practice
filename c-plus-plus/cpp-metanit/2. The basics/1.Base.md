# Инициализация
В C++ есть три вида инициализации:

- Нотация присваивания (assignment notation)
```cpp
int age;
age = 20;
```
- Функциональная нотация (functional notation)
```cpp
int age (38);
```
- Инициализация в фигурных скобках (braced initialization)
```cpp
int age {38};
```

# Типы данных
| Тип            | Размер            |Значение| ex|По умолчанию|                                                 
| ----------- | ----------------|----------|--|------------------- |
|bool| 1 байт (8 бит) | 1 (true) и 0 (false)||false|
|signed char|1 байт (8 бит) |[-128; 127]|||
|unsigned char|1 байт (8 бит) |[ 0; 255] |||
|char|1 байт (8 бит) |  [-128; 127] or [0; 255] ||один символ в кодировке ASCII|
|wchar_t|Win: 2 (16), Lin 4 (32)|  [0;65 535] or [0; 4 294 967 295] |L'A' or L'\x41'| расширенный символ, поток std::wcout:|
|char8_t|1 байт (8 бит) |  [-128; 127] or [0; 255] |u8'l|один символ в Unicode|
|char16_t|2 байта (16 бит) |  [0; 65 535] |u'l'|один символ в Unicode|
|char32_t|4 байт (32 бит) |  [0; 4 294 967 295] |U'o'|один символ в Unicode|
|short |2 байта (16 бит) | [–32768; 32767] ||(short int / signed short int / signed short)|
|unsigned short |2 (16 бит) | [0; 65535]| | (unsigned short int)|
|int |2  (16 бит) или 4 байта (32 бита)|[–32768; 32767] или [−2 147 483 648; 2 147 483 647||(signed int / signed)
|unsigned int |2 (16 бит) или 4 байта (32 бита) |[ 0; 65535 ] или [0; 4 294 967 295]|1024U |(unsigned )|
|long | 4 (32) или 8 (64) байт|[−2 147 483 648; 2 147 483 647] или [−9 223 372 036 854 775 808; +9 223 372 036 854 775 807]|-2048L|(long int / signed long int / signed long)|
|unsigned long|4 байта (32 бита) | [0; 4 294 967 295]| 2048UL|(unsigned long int)|
|long long |8 байт (64 бита)|[−9 223 372 036 854 775 808; +9 223 372 036 854 775 807]|-4096LL|(long long int / signed long long int / signed long long)|
|unsigned long long|8 байт (64 бита) |[0;18 446 744 073 709 551 615]| 4096UL| (unsigned long long int)|
|float| 4 байта (32 бита)| [+/-3.4E-38; 3.4E+38]|10.56f |1 знаковый бит, 8 бит для экспоненты и 23 для мантиссы|
|double|8 байт (64 бита)| [+/- 1.7E-308; 1.7E+308]| 2.5e-3 |1 знаковый бит, 11 бит для экспоненты и 52 бит для мантиссы|
|long double| 8 байт (64 бит)| |10.56l||

Узать размер переменно: `sizeof()`

Разделение разрядов числа: `1'234'567'890`

# Системы исчисления
|Система|Значение|Десятичная|
|-------|--------|----------|
|шестнадцатеричная|0x1A|26|
|восьмеричная|034|26|
|двоичная|0b11010|26|

|Десятиричная|двоичная 0b |Шестнадцатиричная 0х |Восьмиричная|
|-------|--------|----------|----------|
|0|0|0|0|
|1|0001|1|1|
|2|0010|2|2|
|3|0011|3|3|
|4|0011|4|4|
|5|0101|5|5|
|6|0110|6|6|
|7|0111|7|7|
|8|1000|8|8|
|9|1001|9|11|
|10|1010|A|12|
|11|1011|B|13|
|12|1100|C|14|
|13|1101|D|15|
|14|1110|E|16|
|15|1111|F|17|
|16|0001'0000|10|20|
|17|0001'0001|11|21|
|31|0001'1111|1F|37|
|32|0010'0000|20|40|
|63|0011'1111|3F|77|
|64|0100'0000|40|100|
|127|0111'1111|7F|177|
|128|1000'0000|80|200|
|255|1111'1111|FF|377|
|256|0001'0000'0000|100|400|
|511|0001'1111'1111|1FF|777|
|512|0010'0000'0000'|200|1'000|
|1'023|0011'1111'1111|3FF|1'777|
|1'024|0100'0000'0000|400|2'000|
|2'047|0111'1111'1111|7FF|3'777|
|2'048|1000'0000'0000|800|4'000|
|4'095|1111'1111'1111|FFF|7'777|
|4'096|0001'0000'0000'0000|1'000|10'000|
|8'191|0001'1111'1111'1111|1FFF|17'777|
|8'192|0010'0000'0000'0000|2'000|20'000|
|16'833|0011'1111'1111'1111|3FFF|37'777|
|16'834|0100'0000'0000'0000|4'000|40'000|
|32'767|0111'1111'1111'1111|7FFF|77'777|
|32'768|1000'0000'0000'0000|8'000|100'000|
|65'535|1111'1111'1111'1111|FFFF|177'777|
|65'536|0001'0000'0000'0000'0000|10'000|200'000|
|131'071|0001'1111'1111'1111'1111|1FFFF|377'777|
|131'072|0010'0000'0000'0000'0000|20'000|400'000|
# [Таблица ASCII](https://blog.skillfactory.ru/wp-content/uploads/2023/03/image-52-1024x712.png)
|int|char |
|-------|--------|
|0|48|
|1|49|
|2|50|
|3|51|
|4|52|
|5|53|
|6|54|
|7|55|
|8|56|
|9|57|
# Числа с плавающей точкой
Число с плавающей точкой состоит из двух частей: мантиссы и показателя степени. Оба могут быть как положительными, так и отрицательными. Величина числа – это мантисса, умноженная на десять в степени экспоненты.
Например, число `365` может быть записано в виде числа с плавающей точкой следующим образом: `3.650000E02`
В качестве разделителя целой и дробной частей используется символ точки. Мантисса здесь имеет семь десятичных цифр - `3.650000`, 
показатель степени - две цифры `02`. Буква E означает экспоненту, после нее указывается показатель степени (степени десяти), на которую умножается часть `3.650000` (мантисса), чтобы получить требуемое значение. То есть, чтобы вернуться к обычному десятичному представлению, нужно выполнить следующую операцию: `3.650000 × 102 = 365`.

# Спецификатор auto
спецификатор auto предоставляет компилятору самому выводить тип объекта. При этом переменная должна быть обязательно инициализирована каким-либо значением.
На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются
```cpp
auto number = 5;        // number имеет тип int
auto sum {1234.56};    // sum имеет тип double
auto distance {267UL};  // distance имеет тип unsigned long
```
# Константы
```cpp
const int age;
```

# Ввод и вывод в консоли

Средства для ввода/вывода с предоставляются библиотекой `iostream`. В ней определены два типа: `istream` - поток ввода (`cin>>`), `ostream` - поток вывода (`cout <<`).
```cpp
std::cin >> age >> weight; // вводим через пробел
```
# using. Подключение пространств имен и определение псевдонимов
`std::` префикс указывает, что объекты `cout`, `cin`, `endl` определены в пространстве имен `std`. А само двойное двоеточие `::` представляет оператор области видимости `(scope operator)`, который позволяет указать, в каком пространстве имен определен объект. 
```cpp
using пространство_имен::объект
```
или
```cpp
#include <iostream>
using std::cin;
using std::cout;
using std::endl;
```
Ключевое слово `using` также позволяет определять псевдонимы для типов. Это может пригодиться, когда мы работаем с типами с длинными названиями, а определение коротких псевдонимов позволит сократить код. Это именно определение псевдонима, а НЕ определение нового типа.Например:
```cpp
#include <iostream>
 
using ullong = unsigned long long;
int main()
{
    ullong n {10234};
    std::cout << n << std::endl;
}
```
Для определения псевдонимов в С++ используется оператор `typedef`:
```cpp
#include <iostream>
 
typedef unsigned long long ullong;
int main()
{
    ullong n {10234};
    std::cout << n << std::endl;
}
```
# Арифметические операции
Арифметические операции могут быть бинарными (производятся над двумя операндами) и унарными (выполняются над одним операндом).
## Бинарные операции
|Название | Обоначение | Пример|Комментарий | 
| ----------- | ----------------|----------|--|
|сложение | + |c {a + b}| |
|вычитание | - |c {a - b}| |
|умножение | * |c {a * b}| |
|деление | / |c {a / b}| |
|остаток от деления | % |c {a % b}|при делении положительного числа на 0, результат +infinity, при делении отрицательного числа на 0 -infinity |
### NaN (не число). 
Это значение представляет результат операции, который не определяется математически, например, когда `0/0` или `бесконечность/бесконечность`. Результатом любой операции, в которой один или оба операнда являются `NaN`, также является `NaN`.
## Унарные операции
|Название | Обоначение |Комментарий | 
| ----------- | ----------------|----------|
|Префиксный инкремент|++x|Увеличивает значение переменной на единицу и полученный результат используется как значение выражения| 
|Постфиксный инкремент|x++|Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу| 
|Префиксный декремент|--x|Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x| 
|Постфиксный декремент|x--|Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу| 
 ### Операции в порядке уменьшения приоритета:
```cpp
++ (инкремент), -- (декремент)
* (умножение), / (деление), % (остаток от деления)
+ (сложение), - (вычитание)
```
# Статическая типизация и преобразования типов
Для выполнения явных преобразований типов (explicit type conversion) применяется оператор `static_cast`: 
#### static_cast<type>(value)
Данный оператор преобразует значение `value` к  `type`. Слово static в названии оператора отражает тот факт, что приведение проверяется статически, то есть во время компиляции. Применение оператора static_cast указывает компилятору, что мы уверены, что в этом месте надо применить преобразование, поэтому даже при инициализации в фигурных скобках компилятор не сгенерирует ошибку.
Также можно встрить вариант:
#### (type)value
# Поразрядные операции
 ### Операции сдвига
Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:
`<<` - cдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом (сдвиг влево на n аналогичен умножению числа на 2n)
`>>` - cдвигает битовое представление числа вправо на определенное количество разрядов (сдвиг вправо на n разрядов аналогичен делению на 2n)
```cpp
unsigned int a = 2 << 2;          // 10  на два разрядов влево = 1000 - 8
unsigned int b = 16 >> 3;         // 10000 на три разряда вправо = 10 - 2
```
Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.
Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.
 ### Поразрядные операции
|Знач|Назв| | |Комментарий|
|---|---|---|----|----|
|`&`|конъюнкция|И|умножение|Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1|
|`!`|дизъюнкция|ИЛИ|сложение|Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1|
|`^`||исключающее ИЛИ||Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1|
|`~`|||| Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.|
### Логические операции
|Знач|Назв|Комментарий|
|---|---|---|
|&&|конъюнкция, логическое умножение|Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.|
|!!|дизъюнкция, логическое сложение|Возвращает true, если хотя бы один операнд равен true. Возвращает false, если оба операнда равны false.|
|!|отрицание|Унарная операция, которая возвращает true, если операнд равен false. Если операнд равен true, операция возвращает false.|
|^|XOR или eXclusive OR|Возвращает true, если хотя бы оба операнда имеют разные значения. Возвращает false, если оба операнда равны.|
