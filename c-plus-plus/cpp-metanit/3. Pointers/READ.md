# Определение указателя
Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту.

Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *:
```cpp
тип_данных* название_указателя;
int* p; // может хранить только адрес переменной типа int, но пока он не ссылается ни на какой объект и хранит случайное значение. 
```
 Также можно явным образом инициализировать нулем, например, используя специальную константу nullptr:
```cpp
int* p{nullptr};
```
Положение звездочки не влияет на определение указателя: ее можно помещать ближе к типу данных, либо к имени переменной - оба определения будут равноценны:
```cpp
int* p1{};
int *p2{};
```
Размер значения указателя (хранимый адрес) зависит от конкретной платформы. На 32-разрядных платформах размер адресов равен <b>4 байтам</b>, а на 64-разрядных - <b>8 байтам</b>.
### Получение адреса и оператор &
С помощью операция <b>&</b> можно получить адрес некоторого объекта, например, адрес переменной. Затем этот адрес можно присвоить указателю:
```cpp
int number {25};
int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
```
Выражение &number возвращает адрес переменной number. Поэтому переменная pnumber будет хранить адрес переменной number. Переменная number имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу. Однако также можно использовать ключевое слово auto:
```cpp
int number {25};
auto *pnumber {&number}; // указатель pnumber хранит адрес переменной number
```
 Адрес переменной представляет шестнадцатиричное значение.
```cpp
    int number {25};
    int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
    std::cout << "number addr: " << pnumber << std::endl; // адрес переменной
    std::cout << "pnumber addr: " << &pnumber << std::endl; // адрес указателя
```
### Получение значения по адресу
Так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной number. Для этого применяется операция <b>*</b> или операция <b>разыменования</b> ("indirection operator" / "dereference operator"). Результатом этой операции всегда является объект, на который указывает указатель.
```cpp
    int number {25};
    int *pnumber {&number};
    std::cout << "Address = " << pnumber<< std::endl;
    std::cout << "Value = " << *pnumber << std::endl;
```
Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
```cpp
int n1 {25};
int *pn1 {&n1}; // указатель pn1 хранит адрес переменной n1
int n2 { *pn1}; // n2 получает значение, которое хранится по адресу в pn1
std::cout << "n2 = " << n2 << std::endl;  // n2=25
```
И также используя указатель, мы можем менять значение по адресу, который хранится в указателе. Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.
```cpp
int x = 10;
int *px = &x;
*px = 45;
std::cout << "x = " << x << std::endl;     // 45
```
# Операции с указателями
## Присваивание адреса
Указателю можно присвоить адрес объекта того же типа, либо значение другого указателя. При этом указатель и переменная должны иметь один и тот же тип. Для получения адреса объекта используется операция <b>&</b>:
```cpp
int a {10};
int *pa {&a};   // указатель pa хранит адрес переменной a
```
## Разыменование указателя
Операция разыменования указателя представляет выражение в виде <b>*имя_указателя</b>. Эта операция позволяет получить объект по адресу, который хранится в указателе.
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int *pa {&a};   // хранит адрес переменной a
 
    std::cout << "*pa = " << *pa << std::endl;  // *pa = 10 - получить значение по адресу, который хранится в указателе pa
    std::cout << "a = " << a << std::endl;      // a = 10
 
    *pa = 25;   // меняем значение по адресу в указателе (*pa = значение вложить по этому адресу новое значение)
      // Так как в данном случае указатель pa указывает на переменную a,
      //то при изменении значения по адресу, на который указывает указатель, также изменится и значение переменной a.

    std::cout << "*pa = " << *pa << std::endl;  // *pa = 25
    std::cout << "a = " << a << std::endl;      // a = 25
}
```
## Присвоение указателю другого указателя
Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель:
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int b {2};
       
    int *pa {&a};   // указатель на переменную a
    int *pb {&b};   // указатель на переменную b
       
    std::cout << "pa: address=" << pa << "\t value=" << *pa << std::endl;
    std::cout << "pb: address=" << pb << "\t value=" << *pb << std::endl;
       
    pa = pb;    // теперь указатель pa хранит адрес переменной b
    std::cout << "pa: address=" << pa << "\t value=" << *pa << std::endl;
    *pa = 125;  // меняем значение по адресу в указателе pa
    std::cout << "b value=" << b << std::endl;
}
```
## Нулевые указатели
Нулевой указатель (null pointer) - это указатель, который не указывает ни на какой объект. Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение. Для определения нулевого указателя можно инициализировать указатель нулем или константой nullptr:
```cpp
int *p1{nullptr};
int *p2{};
```
## Ссылки на указатели
Так как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или изменять адрес самого указателя `*&pRef {p}`:
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int b {6};
     
    int *p{};           // указатель
    int *&pRef {p};     // ссылка на указатель
    pRef = &a;          // через ссылку указателю p присваивается адрес переменной a
    std::cout << "p value=" << *p << std::endl;   // 10
    *pRef = 70;         // изменяем значение по адресу, на который указывает указатель
    std::cout << "a value=" << a << std::endl;    // 70
     
    pRef = &b;          // изменяем адрес, на который указывает указатель
    std::cout << "p value=" << *p << std::endl;   // 6
}
```
## Адрес указателя
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию &:
```cpp
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a
```
## Операции сравнения
К указателям могут применяться операции сравнения >, >=, <, <=,==, !=. Операции сравнения применяются только к указателям одного типа. Для сравнения используются номера адресов:
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int b {20};
    int *pa {&a};
    int *pb {&b};
     
    if(pa > pb)
        std::cout << "pa (" << pa << ") is greater than pb ("<< pb << ")" << std::endl;
    else
        std::cout << "pa (" << pa << ") is less or equal pb ("<< pb << ")" << std::endl;
}
```
## Приведение типов
Иногда требуется присвоить указателю одного типа значение указателя другого типа. В этом случае следует выполнить операцию приведения типов с помощью операции (тип_указателя *):
```cpp
#include <iostream>
 
int main(){
    char c {'N'};
    char *pc {&c};            // указатель на символ
    int *pd {(int *)pc};      // указатель на int
    void *pv {(void*)pc};     // указатель на void
    std::cout << "pv=" << pv << std::endl;
    std::cout << "pd=" << pd << std::endl;
}
```
Для преобразования указателя к другому типу в скобках перед указателем ставится тип, к которому надо преобразовать. Причем если мы не можем просто создать объект, например, переменную типа void, то для указателя это вполне будет работать. То есть можно создать указатель типа void.

Кроме того, следует отметить, что указатель на тип char `(char *pc {&c})` при выводе на консоль система интерпретирует как строку.
Поэтому если мы хотим вывести на консоль адрес, который хранится в указателе типа char, то это указатель надо преобразовать к другому типу, например, к <b>void* или к int*</b>.
## Арифметика указателей
- <b>Операция инкремента ++p</b> увеличивает значение на единицу. В случае с указателем увеличение на единицу будет означать увеличение адреса, который хранится в указателе, на размер типа указателя. То есть в данном случае указатель на тип int, а размер объектов int в большинстве архитектур равен 4 байтам. Поэтому увеличение указателя типа int на единицу означает увеличение адреса в указателе на 4. Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, который находится за текущим и на который указывает указатель. А уменьшение на единицу означает переход назад к предыдущему объекту в памяти. После изменения адреса мы можем получить значение, которое находится по новому адресу, однако это значение может быть неопределенным.

В случае с указателем типа int увеличение/уменьшение на единицу означает изменение адреса на 4. Аналогично, для указателя типа short эти операции изменяли бы адрес на 2, а для указателя типа char на 1.

- В отличие от сложения операция вычитания может применяться не только к указателю и целому числу, но и к двум указателям одного типа. Результатом разности двух указателей является "расстояние" между ними. Например, из первого указателя на 4 больше, чем адрес из второго указателя (0x6258fffab0 + 4 = 0x6258fffab4). Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно (0x6258fffab4 - 0x6258fffab0)/4 = 1.
# Константы и указатели
Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:
```cpp
    const int a {10};
    const int *pa {&a};
```
Здесь указатель pa указывает на константу a. Мы не можем изменить значение по адресу, который хранится в указателе.
Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную: В этом случае переменную отдельно мы сможем изменять, однако по прежнему изменить ее значение через указатель мы не сможем.

Через указатель на константу мы не можем изменять значение переменной/константы. Но мы можем присвоить указателю адрес любой другой переменной или константы.
## Константный указатель
Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.
```cpp
int a {10};
    int *const pa {&a};
    std::cout << "value=" << *pa << std::endl;      // value = 10
    *pa = 22;                                       // меняем значение
    std::cout << "value=" << *pa << std::endl;      // value = 22
   
    int b {45};
    // pa = &b;         так нельзя сделать
```
## Константный указатель на константу
И объединение обоих предыдущих случаев - константный указатель на константу, который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:
```cpp
int main()
{
    int a {10};
    const int *const pa {&a};
 
    //*pa = 22;  так сделать нельзя
 
    int b {45};
    // pa = &b;  так сделать нельзя 
}
```
# Указатели и массивы
Имя массива является адресом его первого элемента. Через операцию разыменования можно получить значение по этому адресу:
```cpp
#include <iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    std::cout << "nums[0] address: " << nums << std::endl;
    std::cout << "nums[0] value: " << *nums << std::endl;
}
```
Прибавляя к адресу первого элемента некоторое число, мы можем получить определенный элемент массива. То есть, адрес второго элемента будет представлять выражение nums+1, а его значение - *(nums+1).
```cpp
#include <iostream>
  
int main(){
    int nums[] {1, 2, 3, 4, 5};
    int num2 = *(nums + 1);    // второй элемент
    int num3 = *(nums + 2);    // третий элемент
    std::cout << "num2 = " << num2 << std::endl;    // num2 = 2
    std::cout << "num3 = " << num3 << std::endl;    // num3 = 3
}
```
В отношении сложения и вычитания здесь действуют те же правила, что и в операциях с указателями. Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива. Так, в данном случае массив представляет тип int, размер которого, как правило, составляет 4 байта, поэтому прибавление единицы к адресу означает увеличение адреса на 4. Прибавляя к адресу 2, мы увеличиваем значение адреса на 4 * 2 = 8. И так далее.

Пройти цикл по элементам
```cpp
#include <iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    for(unsigned i{}; i < std::size(nums); i++)
    {
        std::cout << "nums[" << i << "]: address=" << nums+i << "\tvalue=" << *(nums+i) << std::endl;
    }
}
```
Имя массива - не стандартный указатель, и мы не можем изменить его адрес, например, так:
```cpp
int nums[] {1, 2, 3, 4, 5};
nums++;         // так сделать нельзя
int b {8};
nums = &b;          // так тоже сделать нельзя
```
## Указатели на массивы
Имя массива всегда хранит адрес самого первого элемента. И нередко для перемещения по элементам массива используются отдельные указатели. Здесь указатель ptr изначально указывает на первый элемент массива. Увеличив указатель на 2, мы пропустим 2 элемента в массиве и перейдем к элементу nums[2].
```cpp
int nums[] {1, 2, 3, 4, 5};
int *ptr {nums};
int num3 = *(ptr+2);
std::cout <<  "num3: " << num3 << std::endl;  // num3: 3
```

Можно сразу присвоить указателю адрес конкретного элемента массива:
```cpp
int nums[] {1, 2, 3, 4, 5};
int *ptr {&nums[2]};    // адрес третьего элемента
std::cout << "*ptr = " << *ptr  << std::endl; //*ptr = 3
```
С помощью указателей легко перебрать массив:
```cpp
#include <iostream>
  
int main(){
    const int n = 5;
    int nums[n]{1, 2, 3, 4, 5};
 
    for(int *ptr{nums}; ptr<=&nums[n-1]; ptr++) std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
}
```
Так как указатель хранит адрес, то мы можем продолжать цикл, пока адрес в указателе не станет равным адресу последнего элемента.

Аналогичным образом можно перебрать и многомерный массив:
```cpp
#include <iostream>
 
int main()
{
    int nums[3][4] { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
    unsigned int n { sizeof(nums)/sizeof(nums[0]) };         // число строк
    unsigned int m { sizeof(nums[0])/sizeof(nums[0][0]) };   // число столбцов
       
    int *end {nums[0] + n * m - 1};    // указатель на самый последний элемент 0 + 3 * 4 - 1 = 11
    int *ptr {nums[0]};                // указатель на первый элемент
    for( unsigned i{1}; ptr <= end; ptr++, i++)    {
        std::cout << *ptr << "\t";
        // если остаток от целочисленного деления равен 0, переходим на новую строку
        if(i%m == 0)  {
            std::cout << std::endl;
        }
    }
}
```
Поскольку в данном случае мы имеем дело с двухмерным массивом, то адресом первого элемента будет выражение a[0]. Соответственно указатель указывает на этот элемент. С каждой итерацией указатель увеличивается на единицу, пока его значение не станет равным адресу последнего элемента, который хранится в указателе end.
Мы также могли бы обойтись и без указателя на последний элемент, проверяя значение счетчика:
```cpp
#include <iostream>
  
int main(){
    const unsigned n {3};           // число строк
    const unsigned m {4};           // число столбцов
    int nums[n][m] { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
    const unsigned count {m * n};   // общее количество элементов
 
    int *ptr{nums[0]};  // указатель на первый элемент первого массива
    for(unsigned i{1}; i <= count; ptr++, i++)    {
        std::cout << *ptr << "\t";
        // если остаток от целочисленного деления равен 0,
        // переходим на новую строку
        if(i%m == 0)     {
            std::cout << std::endl;
        }
    }
}
``` 
## Указатель на строки и массивы символов
Поскольку массив символов может интерпретироваться как строка, то указатель на значения типа char тоже может интерпретироваться как строка:
```cpp
#include <iostream>
  
int main(){
    char hello[] {"hello"};
    char *phello {hello};
    std::cout << phello << std::endl;       // hello
}
```
Также можно применять операцию разыменовывания для получения отдельных символов, например, выведем первый символ:
```cpp
std::cout << *phello << std::endl;      // h
```
Если же необходимо вывести на консоль адрес указателя, то его надо преобразовать к типу void*:
```cpp
std::cout << (void*)phello << std::endl;    // 0x60fe8e
```
В остальном работа с указателем на массив символов производится также, как и с указателями на массивы других типов.
Также поскольку указатель типа char тоже может интерпретироваться как строка, то теоретически мы можем написать следующим образом:
```cpp
char *phello {"hello"};
Однако следует учитывать, что строковые
```
 литералы в С++ рассматриваются как константы. Поэтому предыдущее определение указателя может при компиляции вызвать как минимум предупреждение, а попытка изменить элементы строки через указатель - к ошибке компиляции. Поэтому при определении указателя на строку, следует определять указатель как указатель на константу:
```cpp
#include <iostream>
  
int main()
{
    const char *phello {"hello"}; // указатель на константу
    std::cout << phello << std::endl;   // hello
}
```
## Массивы указателей
Также можно определять массивы указателей. В некотором смысле массив указателей будет похож на массив, который содержит другие массивы. Однако массив указателей имеет преимущества. Например, возьмем обычный двухмерный символьный массив - массив, который хранит строки:
```cpp
#include <iostream>
    
int main(){
    char langs[][20] { "C++", "Python", "JavaScript"};
    std::cout << langs[0] << ": " << std::size(langs[0]) << " bytes" << std::endl;  // C++: 20 bytes
}
```
Для определения двухмерного массива мы должны указать как минимум размер вложенных массивов, который будет достаточным, чтобы вместить каждую строку. В данном случае размер каждого вложенного массива - 20 символов. Однако зачем для первой строки - "C++", которая содержит 4 символа (включая концевой нулевой байт) выделять аж 20 байтов? Это - ограничение подобных массивов. Массивы указателей же позволяют обойти подобное ограничение:
```cpp
#include <iostream>
    
int main(){
    const char *langs[] { "C++", "Python", "JavaScript"};
    // перебор массива
    for(unsigned i{}; i< std::size(langs); i++)    {
        std::cout << langs[i] << std::endl;
    }
}
```
В данном случае элементами массива langs являются указатели: 3 указателя, каждый из которых занимает 4 или 8 байт в зависимости от архитекутуры (размер адреса). Каждый из этих указателей указывает на адрес в памяти, где расположены соответствующие строки: "C++", "Python", "JavaScript". Однако каждая из этих строк будет занимать именно то пространство, которое ей непосредственно необходимо. То есть строка "С++" будет занимать 4 байта. С одной стороны, мы здесь сталкиваемся с дополнительными издержками: дополнительно выделяется память для хранения адресов в указателях. С другой стороны, когда строки в массиве сильно различаются по длине , то мы можем получить общий выигрыш в количестве потребляемой памяти.
