# Определение указателя
Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту.

Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *:
```cpp
тип_данных* название_указателя;
int* p; // может хранить только адрес переменной типа int, но пока он не ссылается ни на какой объект и хранит случайное значение. 
```
 Также можно явным образом инициализировать нулем, например, используя специальную константу nullptr:
```cpp
int* p{nullptr};
```
Положение звездочки не влияет на определение указателя: ее можно помещать ближе к типу данных, либо к имени переменной - оба определения будут равноценны:
```cpp
int* p1{};
int *p2{};
```
Размер значения указателя (хранимый адрес) зависит от конкретной платформы. На 32-разрядных платформах размер адресов равен <b>4 байтам</b>, а на 64-разрядных - <b>8 байтам</b>.
### Получение адреса и оператор &
С помощью операция <b>&</b> можно получить адрес некоторого объекта, например, адрес переменной. Затем этот адрес можно присвоить указателю:
```cpp
int number {25};
int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
```
Выражение &number возвращает адрес переменной number. Поэтому переменная pnumber будет хранить адрес переменной number. Переменная number имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу. Однако также можно использовать ключевое слово auto:
```cpp
int number {25};
auto *pnumber {&number}; // указатель pnumber хранит адрес переменной number
```
 Адрес переменной представляет шестнадцатиричное значение.
```cpp
    int number {25};
    int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
    std::cout << "number addr: " << pnumber << std::endl; // адрес переменной
    std::cout << "pnumber addr: " << &pnumber << std::endl; // адрес указателя
```
### Получение значения по адресу
Так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной number. Для этого применяется операция <b>*</b> или операция <b>разыменования</b> ("indirection operator" / "dereference operator"). Результатом этой операции всегда является объект, на который указывает указатель.
```cpp
    int number {25};
    int *pnumber {&number};
    std::cout << "Address = " << pnumber<< std::endl;
    std::cout << "Value = " << *pnumber << std::endl;
```
Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
```cpp
int n1 {25};
int *pn1 {&n1}; // указатель pn1 хранит адрес переменной n1
int n2 { *pn1}; // n2 получает значение, которое хранится по адресу в pn1
std::cout << "n2 = " << n2 << std::endl;  // n2=25
```
И также используя указатель, мы можем менять значение по адресу, который хранится в указателе. Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.
```cpp
int x = 10;
int *px = &x;
*px = 45;
std::cout << "x = " << x << std::endl;     // 45
```
# Операции с указателями
## Присваивание адреса
Указателю можно присвоить адрес объекта того же типа, либо значение другого указателя. При этом указатель и переменная должны иметь один и тот же тип. Для получения адреса объекта используется операция <b>&</b>:
```cpp
int a {10};
int *pa {&a};   // указатель pa хранит адрес переменной a
```
## Разыменование указателя
Операция разыменования указателя представляет выражение в виде <b>*имя_указателя</b>. Эта операция позволяет получить объект по адресу, который хранится в указателе.
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int *pa {&a};   // хранит адрес переменной a
 
    std::cout << "*pa = " << *pa << std::endl;  // *pa = 10 - получить значение по адресу, который хранится в указателе pa
    std::cout << "a = " << a << std::endl;      // a = 10
 
    *pa = 25;   // меняем значение по адресу в указателе (*pa = значение вложить по этому адресу новое значение)
      // Так как в данном случае указатель pa указывает на переменную a,
      //то при изменении значения по адресу, на который указывает указатель, также изменится и значение переменной a.

    std::cout << "*pa = " << *pa << std::endl;  // *pa = 25
    std::cout << "a = " << a << std::endl;      // a = 25
}
```
## Присвоение указателю другого указателя
Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель:
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int b {2};
       
    int *pa {&a};   // указатель на переменную a
    int *pb {&b};   // указатель на переменную b
       
    std::cout << "pa: address=" << pa << "\t value=" << *pa << std::endl;
    std::cout << "pb: address=" << pb << "\t value=" << *pb << std::endl;
       
    pa = pb;    // теперь указатель pa хранит адрес переменной b
    std::cout << "pa: address=" << pa << "\t value=" << *pa << std::endl;
    *pa = 125;  // меняем значение по адресу в указателе pa
    std::cout << "b value=" << b << std::endl;
}
```
## Нулевые указатели
Нулевой указатель (null pointer) - это указатель, который не указывает ни на какой объект. Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение. Для определения нулевого указателя можно инициализировать указатель нулем или константой nullptr:
```cpp
int *p1{nullptr};
int *p2{};
```
## Ссылки на указатели
Так как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или изменять адрес самого указателя `*&pRef {p}`:
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int b {6};
     
    int *p{};           // указатель
    int *&pRef {p};     // ссылка на указатель
    pRef = &a;          // через ссылку указателю p присваивается адрес переменной a
    std::cout << "p value=" << *p << std::endl;   // 10
    *pRef = 70;         // изменяем значение по адресу, на который указывает указатель
    std::cout << "a value=" << a << std::endl;    // 70
     
    pRef = &b;          // изменяем адрес, на который указывает указатель
    std::cout << "p value=" << *p << std::endl;   // 6
}
```
## Адрес указателя
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию &:
```cpp
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a
```
## Операции сравнения
К указателям могут применяться операции сравнения >, >=, <, <=,==, !=. Операции сравнения применяются только к указателям одного типа. Для сравнения используются номера адресов:
```cpp
#include <iostream>
 
int main(){
    int a {10};
    int b {20};
    int *pa {&a};
    int *pb {&b};
     
    if(pa > pb)
        std::cout << "pa (" << pa << ") is greater than pb ("<< pb << ")" << std::endl;
    else
        std::cout << "pa (" << pa << ") is less or equal pb ("<< pb << ")" << std::endl;
}
```
## Приведение типов
Иногда требуется присвоить указателю одного типа значение указателя другого типа. В этом случае следует выполнить операцию приведения типов с помощью операции (тип_указателя *):
```cpp
#include <iostream>
 
int main(){
    char c {'N'};
    char *pc {&c};            // указатель на символ
    int *pd {(int *)pc};      // указатель на int
    void *pv {(void*)pc};     // указатель на void
    std::cout << "pv=" << pv << std::endl;
    std::cout << "pd=" << pd << std::endl;
}
```
Для преобразования указателя к другому типу в скобках перед указателем ставится тип, к которому надо преобразовать. Причем если мы не можем просто создать объект, например, переменную типа void, то для указателя это вполне будет работать. То есть можно создать указатель типа void.

Кроме того, следует отметить, что указатель на тип char `(char *pc {&c})` при выводе на консоль система интерпретирует как строку.
Поэтому если мы хотим вывести на консоль адрес, который хранится в указателе типа char, то это указатель надо преобразовать к другому типу, например, к <b>void* или к int*</b>.
## Арифметика указателей
- <b>Операция инкремента ++p</b> увеличивает значение на единицу. В случае с указателем увеличение на единицу будет означать увеличение адреса, который хранится в указателе, на размер типа указателя. То есть в данном случае указатель на тип int, а размер объектов int в большинстве архитектур равен 4 байтам. Поэтому увеличение указателя типа int на единицу означает увеличение адреса в указателе на 4. Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, который находится за текущим и на который указывает указатель. А уменьшение на единицу означает переход назад к предыдущему объекту в памяти. После изменения адреса мы можем получить значение, которое находится по новому адресу, однако это значение может быть неопределенным.

В случае с указателем типа int увеличение/уменьшение на единицу означает изменение адреса на 4. Аналогично, для указателя типа short эти операции изменяли бы адрес на 2, а для указателя типа char на 1.

- В отличие от сложения операция вычитания может применяться не только к указателю и целому числу, но и к двум указателям одного типа. Результатом разности двух указателей является "расстояние" между ними. Например, из первого указателя на 4 больше, чем адрес из второго указателя (0x6258fffab0 + 4 = 0x6258fffab4). Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно (0x6258fffab4 - 0x6258fffab0)/4 = 1.
# Константы и указатели
Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:
```cpp
    const int a {10};
    const int *pa {&a};
```
## Константный указатель
Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.
```cpp
int a {10};
    int *const pa {&a};
    std::cout << "value=" << *pa << std::endl;      // value = 10
    *pa = 22;                                       // меняем значение
    std::cout << "value=" << *pa << std::endl;      // value = 22
   
    int b {45};
    // pa = &b;         так нельзя сделать
```
